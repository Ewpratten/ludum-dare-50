use std::{collections::HashMap, sync::Arc};

use crate::asset_manager::{load_texture_from_internal_data, InternalData};
use nalgebra as na;
use raylib::{
    camera::Camera2D, prelude::RaylibDrawHandle, texture::Texture2D, RaylibHandle, RaylibThread,
};
use tiled::{Loader, Map, ResourceCache, ResourcePath, ResourcePathBuf, Tileset};

/// Possible errors generated by the map loading process
#[derive(Debug, thiserror::Error)]
pub enum MapRenderError {
    #[error("Could not load embedded asset: {0}")]
    AssetNotFound(String),
    #[error(transparent)]
    TiledError(#[from] tiled::Error),
}

#[derive(Debug)]
struct ProgramDataTileCache {
    tilesets: HashMap<ResourcePathBuf, Arc<Tileset>>,
    internal_loader: Loader,
}

impl ProgramDataTileCache {
    fn new() -> Self {
        Self {
            tilesets: HashMap::new(),
            internal_loader: Loader::new(),
        }
    }
}

impl ResourceCache for ProgramDataTileCache {
    /// Load the tileset. First attempts to pull from an in-RAM cache, otherwise attempts to load from disk.
    fn get_tileset(&self, path: impl AsRef<ResourcePath>) -> Option<Arc<Tileset>> {
        let possibly_cached_tileset = self.tilesets.get(path.as_ref()).map(Clone::clone);
        if let Some(tileset) = possibly_cached_tileset {
            return Some(tileset);
        } else {
            // Pull the TSX from storage and parse it
            InternalData::get(path.as_ref().to_str().unwrap()).map(|file| {
                let data = file.data.into_owned();
                Arc::new(
                    self.internal_loader
                        .load_tsx_tileset_from(data.as_slice(), path)
                        .unwrap(),
                )
            })
        }
    }

    fn get_or_try_insert_tileset_with<F, E>(
        &mut self,
        path: ResourcePathBuf,
        f: F,
    ) -> Result<Arc<Tileset>, E>
    where
        F: FnOnce() -> Result<Tileset, E>,
    {
        Ok(match self.tilesets.entry(path) {
            std::collections::hash_map::Entry::Occupied(o) => o.into_mut(),
            std::collections::hash_map::Entry::Vacant(v) => v.insert(Arc::new(f()?)),
        }
        .clone())
    }
}

#[derive(Debug)]
pub struct MapRenderer {
    map: Map,
    tile_textures: HashMap<String, HashMap<u32, Texture2D>>,
}

impl MapRenderer {
    /// Construct a new MapRenderer.
    pub fn new(
        tmx_path: &str,
        raylib: &mut RaylibHandle,
        raylib_thread: &RaylibThread,
    ) -> Result<Self, MapRenderError> {
        // Pull the TMX from storage
        let data = InternalData::get(tmx_path)
            .ok_or(MapRenderError::AssetNotFound(tmx_path.to_string()))?
            .data
            .into_owned();

        // Attempt to parse the TMX file
        let mut loader = Loader::with_cache(ProgramDataTileCache::new());
        let map = loader.load_tmx_map_from(data.as_slice(), tmx_path)?;

        // Iterate over all images in the map
        let mut tile_textures = HashMap::new();
        for tileset in map.tilesets() {
            for (idx, tile) in tileset.tiles() {
                if let Some(image) = tile.data.image {
                    // We now have a path to an image
                    let image_path = image.source;

                    // Load the texture
                    let texture = load_texture_from_internal_data(
                        raylib,
                        raylib_thread,
                        image_path.to_str().unwrap(),
                    )
                    .unwrap();

                    // Store the texture in the cache
                    tile_textures
                        .entry(tileset.name)
                        .or_insert_with(HashMap::new)
                        .insert(idx, texture);
                }
            }
        }

        Ok(Self { map, tile_textures })
    }

    pub fn sample_friction_at(&self, position: na::Vector2<f32>) -> f32 {
        todo!()
    }

    pub fn sample_temperature_at(&self, position: na::Vector2<f32>) -> f32 {
        todo!()
    }

    pub fn render_map(&self, draw_handle: &RaylibDrawHandle, camera: &Camera2D) {}
}
