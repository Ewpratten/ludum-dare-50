use std::{collections::HashMap, sync::Arc};

use crate::asset_manager::InternalData;
use nalgebra as na;
use tiled::{Loader, ResourceCache, ResourcePath, ResourcePathBuf, Tileset};

/// Possible errors generated by the map loading process
#[derive(Debug, thiserror::Error)]
pub enum MapRenderError {
    #[error("Could not load embedded asset: {0}")]
    AssetNotFound(String),
    #[error(transparent)]
    TiledError(#[from] tiled::Error),
}

#[derive(Debug)]
struct ProgramDataTileCache {
    tilesets: HashMap<ResourcePathBuf, Arc<Tileset>>,
    internal_loader: Loader,
}

impl ProgramDataTileCache {
    fn new() -> Self {
        Self {
            tilesets: HashMap::new(),
            internal_loader: Loader::new(),
        }
    }
}

impl ResourceCache for ProgramDataTileCache {
    /// Load the tileset. First attempts to pull from an in-RAM cache, otherwise attempts to load from disk.
    fn get_tileset(&self, path: impl AsRef<ResourcePath>) -> Option<Arc<Tileset>> {
        let possibly_cached_tileset = self.tilesets.get(path.as_ref()).map(Clone::clone);
        if let Some(tileset) = possibly_cached_tileset {
            return Some(tileset);
        } else {
            // Pull the TSX from storage and parse it
            InternalData::get(path.as_ref().to_str().unwrap()).map(|file| {
                let data = file.data.into_owned();
                Arc::new(
                    self.internal_loader
                        .load_tsx_tileset_from(data.as_slice(), path)
                        .unwrap(),
                )
            })

            // .ok_or(MapRenderError::AssetNotFound(path.to_string()))?
            // .data
            // .into_owned();
        }
    }

    fn get_or_try_insert_tileset_with<F, E>(
        &mut self,
        path: ResourcePathBuf,
        f: F,
    ) -> Result<Arc<Tileset>, E>
    where
        F: FnOnce() -> Result<Tileset, E>,
    {
        Ok(match self.tilesets.entry(path) {
            std::collections::hash_map::Entry::Occupied(o) => o.into_mut(),
            std::collections::hash_map::Entry::Vacant(v) => v.insert(Arc::new(f()?)),
        }
        .clone())
    }
}

#[derive(Debug)]
pub struct MapRenderer {}

impl MapRenderer {
    /// Construct a new MapRenderer.
    pub fn new(tmx_path: &str) -> Result<Self, MapRenderError> {
        // Pull the TMX from storage
        let data = InternalData::get(tmx_path)
            .ok_or(MapRenderError::AssetNotFound(tmx_path.to_string()))?
            .data
            .into_owned();

        // Attempt to parse the TMX file
        let mut loader = Loader::with_cache(ProgramDataTileCache::new());
        let map = loader.load_tmx_map_from(data.as_slice(), tmx_path)?;

        Ok(Self {})
    }

    pub fn sample_friction_at(&self, position: na::Vector2<f32>) -> f32 {
        todo!()
    }

    pub fn sample_temperature_at(&self, position: na::Vector2<f32>) -> f32 {
        todo!()
    }
}
